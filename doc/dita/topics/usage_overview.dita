<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="Untitled">
    <title>Overview</title>
    
    <prolog>
        <author>Joel Bodenmann</author>
        <metadata>
          <keywords>
              <indexterm>usage
                  <index-see-also>integration</index-see-also>
              </indexterm>
          </keywords>
        </metadata>
    </prolog>
    
    <body>
        <p>This topic explains the usage of the <ph keyref="projectname"/> library. See <xref href="integration_general.dita"/>
            for instructions on how to integrate the library into a project.</p>
        
        <section>
            <title>General usage</title>
            <p>The following figure illustrates how <ph keyref="projectname"/> is used by an address book application:</p>
            <fig>
                <image href="../../uml/exports/svg/Model!Usage_1.svg"/>
            </fig>
        </section>
        
        <section>
            <title>Make class serializable</title>
            <p>A class needs to inherit from the <apiname>Container</apiname> class in order to
                become serializable through <ph keyref="projectname"/>.</p>
        </section>
        
        <example>
            <title>Implement <apiname>Serialize</apiname> interface</title>
            <p>Implement the <apiname>Gpds::Serialize</apiname> interface by inheriting from the
                respective class to make your own class become serializable through <ph
                    keyref="projectname"/> as shown by the following UML class diagram:</p>
            <fig>
                <image href="../../uml/exports/svg/Misc!Example_02_3.svg"/>
            </fig>
            <p>Corresponding C++ code:</p>
            <codeblock outputclass="language-cpp"><![CDATA[class Car : public Gpds::Serialize {
public:
    std::string manufacturer;
    std::string model;
    int year_of_construction;
    Color color;

    virtual Gpds::Container toContainer() const override
    {
        Gpds::Container c;

        c.addValue("manufacturer", manufacturer);
        c.addValue("model", model);
        c.addValue("year_of_construction", year_of_construction);
        c.addValue("color", color.toContainer());

        return c;
    }

    virtual void fromContainer(const Gpds::Container &c) override
    {
        manufacturer = c.getValue<std::string>("manufacturer");
        model = c.getValue<std::string>("model");
        year_of_construction = c.getValue<int>("year_of_construction");
        color.fromContainer( *c.getValue<Gpds::Container*>( "color" ) );
    }
};

class Color : public Gpds::Serialize
{
public:
    std::string name;
    int red;
    int green;
    int blue;

    virtual Gpds::Container toContainer() const override
    {
        Gpds::Container c;

        c.addAttribute("format", "rgb");
        c.addAttribute("name", name);

        c.addValue("red", red).addAttribute("depth", "32");
        c.addValue("green", green).addAttribute("depth", "32");
        c.addValue("blue", blue).addAttribute("depth", "32");

        return c;
    }

    virtual void fromContainer(const Gpds::Container& c) override
    {
        // Retrieve format
        const std::string& formatString = c.getAttribute("format").value_or("n/a");
        assert( formatString == "rgb" );

        name = c.getAttribute("name").value_or("n/a");
        red = c.getValue<int>("red");
        green = c.getValue<int>("green");
        blue = c.getValue<int>("blue");
    }
};]]></codeblock>
            <p>Once serialized with the XML archiver, the following output is produced:</p>
            <codeblock outputclass="language-xml"><![CDATA[<car>
    <color format="rgb" name="Black">
        <blue depth="32">0</blue>
        <green depth="32">0</green>
        <red depth="32">0</red>
    </color>
    <manufacturer>Jeep</manufacturer>
    <model>Grand Cherokee</model>
    <year_of_construction>2009</year_of_construction>
</car>]]></codeblock>
            <note type="note">Values within a container are sorted alphabetically to improve look-up time.</note>
        </example>
        
        <example>
            <title>Serialize</title>
            <p>Create an instance of <apiname>ArchiverXml</apiname> (or of any other
                <apiname>Archiver</apiname> class).</p>
            <p>Call <apiname>Archiver::save()</apiname> to serialize:</p>
            <codeblock outputclass="language-cpp"><![CDATA[Car car;

std::sstream stream;
Gpds::ArchiverXml ar;
ar.save(stream, car, "car");

std::cout << stream.str() << std::endl]]></codeblock>
        </example>
        
        <example>
            <title>Deserialize</title>
            <p>Create an instance of <apiname>ArchiverXml</apiname> (or of any other
                <apiname>Archiver</apiname> class).</p>
            <p>Call <apiname>Archiver::load()</apiname> to serialize:</p>
            <codeblock outputclass="language-cpp"><![CDATA[Car car;

Gpds::ArchiverXml ar;
ar.load(stream, car, "car");]]></codeblock>
        </example>
    </body>
    
    <related-links>
        <link href="integration.dita"/>
        <link href="architecture_overview.dita"/>
    </related-links>
    
</topic>
